<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 6</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
            color: #333;
        }
        h1, h2, h3, h4 {
            color: #0056b3;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        code {
            font-family: "Courier New", Courier, monospace;
            color: #d44950;
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .slide {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fff;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        blockquote {
            border-left: 4px solid #ccc;
            padding-left: 10px;
            margin-left: 0;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Mobile Test Automation - Day 6</h1>
    <h3>Refactoring, Advanced Waits, and Popups</h3>

    <div class="slide">
        <h2>1. Advanced Waits: From Static to Dynamic</h2>
        <h3>The Problem with Static Waits (<code>time.sleep()</code>)</h3>
        <p>In our initial test script (<code>D4/test_saucelabs_flow.py</code>), we used <code>time.sleep()</code> to handle delays in the UI. This is known as a static or "hard" wait, and it's a major anti-pattern in test automation.</p>
        <ul>
            <li><b>It creates slow tests:</b> If the app is fast, the test still waits for the full, hardcoded duration (e.g., <code>time.sleep(1)</code>). This adds up and makes your test suite unnecessarily slow.</li>
            <li><b>It creates flaky tests:</b> If the app is slower than your static wait time (due to network lag, device performance, etc.), the test will try to interact with an element that hasn't appeared yet, causing a <code>NoSuchElementException</code> and failing the test.</li>
        </ul>
        <p>The solution is to use <strong>Dynamic or Explicit Waits</strong>.</p>

        <h3>Introducing Explicit Waits</h3>
        <p>An explicit wait is a dynamic wait where you tell the driver to wait for a certain condition to be met before proceeding. The driver will poll the DOM for a specified maximum amount of time until the condition is true. If the condition is met before the timeout, the test continues immediately. If the condition is not met within the timeout, it throws a <code>TimeoutException</code>.</p>
        
        <h4>Implementing Explicit Waits in our <code>BasePage</code></h4>
        <p>Let's transform our <code>D4/base_page.py</code> into a robust, wait-aware base page.</p>
        <p><b>Before (D4 - No Waits):</b></p>
        <pre><code># In D4/base_page.py
class BasePage:
    def __init__(self, driver):
        self.driver = driver

    def find_element(self, by, locator):
        # Directly finds the element. Fails immediately if not found.
        return self.driver.find_element(by, locator)

    def click_element(self, by, locator):
        self.find_element(by, locator).click()
    # ... other methods followed the same pattern
</code></pre>
        <p><b>After (D5 - With Explicit Waits):</b></p>
        <p>First, we import the necessary modules from Selenium and initialize <code>WebDriverWait</code> in our constructor.</p>
        <pre><code># In D5/base_page.py
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException

class BasePage:
    def __init__(self, driver):
        self.driver = driver
        # Initialize WebDriverWait with a 10-second timeout
        self.wait = WebDriverWait(driver, 10)
</code></pre>
        <p>Next, we create reusable wait methods. Instead of directly finding an element, we wait for it to be in a certain state (e.g., visible, clickable).</p>
        <pre><code># In D5/base_page.py
    def wait_for_visibility_of_element(self, by, locator):
        # Waits up to 10s for an element to be visible on the screen
        return self.wait.until(EC.visibility_of_element_located((by, locator)))

    def wait_for_element_to_be_clickable(self, by, locator):
        # Waits up to 10s for an element to be visible and enabled
        return self.wait.until(EC.element_to_be_clickable((by, locator)))
</code></pre>
        <p>Finally, we refactor our action methods (like <code>click</code> and <code>send_keys</code>) to use these new wait methods. This ensures that we never try to interact with an element before it's ready.</p>
        <pre><code># In D5/base_page.py
    def click_element(self, by, locator):
        # Wait for the element to be clickable, then click it
        self.wait_for_element_to_be_clickable((by, locator)).click()

    def send_keys_to_element(self, by, locator, text):
        # Wait for the element to be visible, then send keys
        self.wait_for_visibility_of_element(by, locator).send_keys(text)
</code></pre>
        <p>With this refactoring, all our page object methods that inherit from <code>BasePage</code> are now robust and dynamic. We can remove all <code>time.sleep()</code> calls from our test script, resulting in faster and much more reliable tests.</p>
    </div>

    <div class="slide">
        <h2>2. Handling Popups and Notifications</h2>
        <p>Mobile applications frequently use native dialogs, popups, and notifications to interact with the user. Automating these requires specific strategies, as they often exist outside the application's main UI hierarchy.</p>
        
        <h3>5.1. Handling Native Android Popups (Alerts)</h3>
        <p>Native popups, such as permission requests ("Allow App to access...") or confirmation dialogs, are part of the Android system UI. UiAutomator2 is excellent at handling these because it has access to the entire device screen, not just the app's window.</p>
        <p>The locators for these popups are standard Android resource IDs. For example:</p>
        <ul>
            <li><b>Popup Title:</b> <code>com.android.internal:id/alertTitle</code> or <code>android:id/alertTitle</code></li>
            <li><b>Popup Message:</b> <code>android:id/message</code></li>
            <li><b>"OK" / "Allow" Button:</b> <code>android:id/button1</code></li>
            <li><b>"Cancel" / "Deny" Button:</b> <code>android:id/button2</code></li>
        </ul>
        <p>We can create methods in our <code>HomePage</code> to interact with a sample popup.</p>
        <pre><code># In D6/home_page.py
class HomePage(BasePage):
    class Locators:
        # ... other locators
        POPUP_TITLE = (AppiumBy.ID, "android:id/alertTitle")
        POPUP_MESSAGE = (AppiumBy.ID, "android:id/message")
        OK_BUTTON = (AppiumBy.ID, "android:id/button1")
        CANCEL_BUTTON = (AppiumBy.ID, "android:id/button2")

    # ...
    def get_popup_title(self):
        return self.get_element_text(*self.Locators.POPUP_TITLE)

    def get_popup_message(self):
        return self.get_element_text(*self.Locators.POPUP_MESSAGE)

    def accept_popup(self):
        self.click_element(*self.Locators.OK_BUTTON)

    def dismiss_popup(self):
        self.click_element(*self.Locators.CANCEL_BUTTON)
</code></pre>

        <h3>5.2. Handling Android Notifications</h3>
        <p>Notifications appear in the system's notification shade at the top of the screen. To interact with them, our automation script needs to perform a sequence of actions:</p>
        <ol>
            <li><b>Open the notification shade:</b> This is done via a specific driver command.</li>
            <li><b>Locate the notification:</b> Notifications also have standard resource IDs. We can look for the title and text.</li>
            <li><b>Interact with the notification:</b> Click it, read its content, or dismiss it.</li>
            <li><b>Close the notification shade:</b> Usually by pressing the back button.</li>
        </ol>

        <h4>Implementation in <code>BasePage</code></h4>
        <p>Since notifications are a system-level feature, it's best to add helper methods to our <code>BasePage</code>.</p>
        <pre><code># In D6/base_page.py
class BasePage:
    # ...
    def open_notifications(self):
        self.driver.open_notifications()

    def is_notification_displayed(self, expected_title):
        try:
            notification_title_locator = (AppiumBy.XPATH, f"//*[@resource-id='android:id/title' and @text='{expected_title}']")
            self.wait_for_visibility_of_element(*notification_title_locator)
            return True
        except TimeoutException:
            return False
        finally:
            self.driver.back() # Always close the notification shade

    def get_notification_text(self, expected_title):
        try:
            # Find the title to anchor our search
            title_element = self.wait_for_visibility_of_element(AppiumBy.XPATH, f"//*[@resource-id='android:id/title' and @text='{expected_title}']")
            # The notification text is often a sibling element
            notification_text = title_element.find_element(AppiumBy.XPATH, "following-sibling::*[@resource-id='android:id/text']").text
            return notification_text
        except Exception:
            return None
        finally:
            self.driver.back() # Always close the notification shade
</code></pre>
        <p>These methods allow our test script to open the notification shade, verify if a specific notification is present, and extract its content, ensuring the test is robust and handles system interactions correctly.</p>
    </div>

    <div class="slide">
        <h2>Next Steps: Applying the Refactoring</h2>
        <p>Now, let's apply these concepts to our Day 4 code. We will refactor the test script and page objects to be more robust and maintainable.</p>
    </div>

</body>
</html>